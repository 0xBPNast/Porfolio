# -*- coding: utf-8 -*-
"""TSA_v16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ui8QlTdWl1AO7qZKt9QtSdp_1i_lhoGN
"""

import numpy as np

def tsa(tacho, Fs_tacho, signal, Fs_signal, tacho_trigger, tacho_ppr):

  # tacho         = Tachometer signal (1D)
  # Fs_tacho      = Tachometer signal sampling frequency [Hz]
  # signal        = Vibration signal for TSA (1D)
  # Fs_signal     = Vibration signal sampling frequency [Hz]
  # tacho_trigger = Tachometer signal trigger value
  # tacho_ppr     = Pulses per revolution

  # Define tacho signal parameters
  dt_tacho = 1/Fs_tacho                             # Tacho signal time step
  N_tacho = np.size(tacho)                          # No. of Samples for Tacho
  tf_tacho = dt_tacho * N_tacho                     # End time for tacho signal
  t_tacho = np.arange(0, tf_tacho, dt_tacho)        # Tacho signal time array

  # Find time points/array indices of tacho pulses
  ind_tac = np.where(tacho == tacho_trigger)
  ind_tac = ind_tac[0]                              # Reshape

  # Get time points at each PPRth Pulse (Each Revolution, Tacho Signal)
  tf_window = t_tacho[ind_tac[tacho_ppr - 1]]       # Time at first PPR Pulse
  Nr = int(np.floor(len(ind_tac)/tacho_ppr))        # No. of windows
  ind_ppr_tac = np.zeros(Nr)                        # PPRth index storage array (tacho)

  # Loop through revolutions to get tacho PPRth indices
  for i in range(1, Nr+1):
    ind_ppr_tac[i-1] = ind_tac[tacho_ppr*i - 1]

  # Prep tacho PPRth indices
  ind_ppr_tac = ind_ppr_tac.astype(int)             # Ensure indices are integers

  # Get time points corresponding to PPRth indices
  t_tacho_pprs = t_tacho[ind_ppr_tac]               # Get time points at PPRth indices

  # Define vibration signal parameters
  dt_signal = 1/Fs_signal                           # Vib. signal time step
  N_signal = np.size(signal)                        # No. of samples for vib.
  tf_signal = dt_signal * N_signal                  # End time for vib. signal
  t_signal = np.arange(0, tf_signal, dt_signal)     # Vib signal time array
  ind_ppr_sig = np.zeros(len(ind_ppr_tac))          # PPRth index storage array (signal)

  # Correlate t_tacho_pprs with t_signal & get index
  for i in range(0, len(t_tacho_pprs)):
    ind_ppr_sig[i] = np.argmin(abs(t_signal - t_tacho[ind_ppr_tac[i]]))
  
  ind_ppr_sig = ind_ppr_sig.astype(int)

  # Check if no. of samples are equal between indices (signal)
  diff_check = np.diff(ind_ppr_sig)

  # Define next power
  def nextpower(value):

    power = 2**np.arange(0, 16, 1)

    for i in range(0, len(power)):

      if value - power[i] >= 0:
        pass
      else:
        return power[i]

  # Interpolate if spacing between ppr indices are not equal
  if np.mean(diff_check) != 0:

    Ns = nextpower(diff_check[0])                     # Interpolation samples (next power of 2)
    Ns_tot = Ns*Nr
    t_ns = []
    s_ns = []
    x_tsa = np.zeros(Ns)

    for i in range(0, Nr):

      if i == 0:
        t_start = 0
        t_end = t_signal[ind_ppr_sig[i]]
      else:
        t_start = t_signal[ind_ppr_sig[i-1]]
        t_end = t_signal[ind_ppr_sig[i]]
      
      t_int = np.linspace(t_start, t_end, Ns)
      t_ns.append(t_int)
      sig_int = np.interp(t_int, t_signal, signal)
      s_ns.append(sig_int)

      x_tsa += sig_int

    t_ns = np.array(t_ns).reshape(-1)
    s_ns = np.array(s_ns).reshape(-1)
    x_tsa = x_tsa/Nr
    x_tsa_nr = np.zeros(len(t_ns))

    cnt = 1

    for i in range(0, Nr):

      frame_start = i*Ns
      frame_end = cnt*Ns

      x_tsa_nr[frame_start:frame_end] = x_tsa
      cnt += 1

    x_tsa_nr = np.interp(t_signal[:ind_ppr_sig[-1]], t_ns, x_tsa_nr)
    
    return ("Reinterpolated", x_tsa_nr, Ns, Ns_tot, Nr, t_tacho, ind_ppr_tac, t_signal, ind_ppr_sig)
    
  if np.mean(diff_check) == 0:

    Ns = diff_check[i]
    Ns_tot = Ns*Nr
    average = 0
    count = 0
    t_signal_pprs = t_signal[ind_ppr_sig]

    for i in range(0, len(t_signal_pprs), Ns):
      
      average += signal[i:i+Ns]
      count += 1

      if count == Nr:
        x_tsa = average/count

      cnt = 1

    x_tsa_nr = np.zeros(len(t_signal_pprs))

    for i in range(0, Nr):

      frame_start = i*Ns
      frame_end = cnt*Ns

      x_tsa_nr[frame_start:frame_end] = x_tsa
      cnt += 1

      return ("Standard", x_tsa_nr, Ns, Ns_tot, Nr, t_tacho, ind_ppr_tac, t_signal, ind_ppr_sig)